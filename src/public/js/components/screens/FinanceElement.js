import { Map as ImmutableMap } from 'immutable';

import React from 'react';
import { connect } from 'react-redux';
import { format } from 'currency-formatter';

import budgetBalance from '../../../../shared/js/finance/budgetBalance';
import {m52ToAggregated, hierarchicalAggregated}  from '../../../../shared/js/finance/memoized';
import {flattenTree} from '../../../../shared/js/finance/visitHierarchical.js';
import navigationTree from '../../navigationTree';
import { EXPENDITURES, REVENUE } from '../../constants/pages';

/*
    In this component, there are several usages of dangerouslySetInnerHTML.

    In the context of the public dataviz project, the strings being used are HTML generated by 
    a markdown parser+renderer. This part is considered trusted enough.

    The content being passed to the markdown parser is created and reviewed by the project team and likely
    by the communication team at the Département de la Gironde. So this content is very very unlikely to ever
    contain anything that could cause any harm.

    For these reasons, the usages of dangerouslySetInnerHTML are fine.
*/

/*

interface FinanceElementProps{
    contentId: string,
    amount, // amount of this element
    aboveTotal, // amount of the element in the above category
    topTotal // amount of total expenditures or revenue
    texts: FinanceElementTextsRecord,

    // the partition will be displayed in the order it's passed. Sort beforehand if necessary
    partition: Array<{
        contentId: string,
        partAmount: number,
        texts: FinanceElementTextsRecord,
        url: string
    }>
}

*/

export function FinanceElement({contentId, amount, aboveTotal, topTotal, texts, partition, year, urls}) {
    const label = texts && texts.get('label');
    const atemporalText = texts && texts.get('atemporal');
    const yearText = texts && texts.get('byYear') && texts.get('byYear').get(year);

    return React.createElement('article', {className: 'finance-element'}, 
        React.createElement('h1', {className: label ? '' : 'missing', 'data-id': contentId}, label), 
        React.createElement('h3', {}, format(amount, { code: 'EUR' })),
        
        React.createElement('div', {className: 'ratios'}, 
            React.createElement('div', {className: 'proportion-container'},
                React.createElement('div', {className: 'proportion', style: {width: 100*amount/aboveTotal+'%'}}, 'Catégorie dessus')
            ),
            React.createElement('div', {className: 'proportion-container'},
                React.createElement('div', {className: 'proportion', style: {width: 100*amount/topTotal+'%'}}, 'Dépenses ou recettes totales')
            )
        ),

        atemporalText ? React.createElement('section', {className: 'atemporal', dangerouslySetInnerHTML: {__html: atemporalText}}) : undefined,

        React.createElement('h2', {}, 'Évolution sur ces dernières années'),
        React.createElement('scatter-plot', {}, ''),
        //yearText ? React.createElement('h3', {}, "Considérations spécifiques à l'année ",year) : undefined,
        //yearText ? React.createElement('section', {dangerouslySetInnerHTML: {__html: yearText}}) : undefined,


        partition ? React.createElement('section', { className: 'partition'}, 
            partition.map(({contentId, partAmount, texts, url}) => {
                return React.createElement('a',
                    {
                        href: url
                    }, 
                    React.createElement('h1', {}, texts && texts.get('label') || contentId),
                    React.createElement('h2', {},
                        format(partAmount, { code: 'EUR' }),
                        ' ',
                        (100*partAmount/amount).toFixed(1)+'%'
                    ),
                    React.createElement('p', texts && texts.get('atemporal'))
                );
            })  
        ) : undefined 

    );
}



function makePartition(contentId, totalById, textsById){
    const childrenIds = navigationTree[contentId];

    return childrenIds ? childrenIds.map(childId => ({
        contentId: childId,
        partAmount: totalById.get(childId),
        texts: textsById.get(childId),
        url: '#!/finance-details/'+childId
    })) : undefined;
}



function getElementById(m52Instruction, aggregated){

    let elementById = new ImmutableMap();

    aggregated.forEach(aggRow => {
        elementById = elementById.set(aggRow.id, aggRow);
    });

    ['D', 'R'].forEach(rd => {
        ['F', 'I'].forEach(fi => {
            throw 'TODO fix hierarchicalAggregated usage';
            const hierAgg = hierarchicalAggregated(aggregated, {rd, fi});
            flattenTree(hierAgg).forEach(aggHierNode => {
                elementById = elementById.set(aggHierNode.id, aggHierNode);
            });
        });
    });

    return elementById;
}


export default connect(
    state => {        
        const { m52InstructionByYear, textsById, breadcrumb, currentYear } = state;
        
        const m52Instruction = m52InstructionByYear.get(currentYear);
        const aggregated = m52ToAggregated(m52Instruction);
        
        const displayedContentId = breadcrumb.last();
        
        const balance = m52Instruction ? budgetBalance(m52Instruction) : {};
        let elementById = (m52Instruction && getElementById(m52Instruction, aggregated)) || new ImmutableMap();
        elementById = elementById
            .set(EXPENDITURES, {
                id: EXPENDITURES,
                total: balance.expenditures
            })
            .set(REVENUE, {
                id: REVENUE,
                total: balance.revenue
            })


        const element = elementById.get(displayedContentId);

        // weak. TODO : make a stronger test
        const expenseOrRevenue = element && element.id ? 
            (element.id.startsWith('D') ? EXPENDITURES : REVENUE) : 
            undefined;

        const amount = m52Instruction && element.total;

        throw 'TODO topElement id'

        return Object.assign(
            {
                contentId: displayedContentId, 
                amount, 
                parentElement: element.parent, 
                topElement: {
                    id: 12
                }, 
                texts: textsById.get(displayedContentId),
                partition: makePartition(displayedContentId, totalById, textsById),
                year: currentYear
            }
        )

    },
    () => ({})
)(FinanceElement);